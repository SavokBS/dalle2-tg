import base64
import json
import random
import traceback
import requests
import re
from googletrans import Translator
from aiogram import Bot, Dispatcher, executor
from db import DB
from cdb import CDB
TOKEN = "YOUR_BOT_TOKEN"
bot = Bot(TOKEN, parse_mode="HTML")
dp = Dispatcher(bot)

translator = Translator()

secret_key = bytes.fromhex('87BE21D68BA406A1381AE46600B2656FA536EFE6FB4A50E7CAAF82D75C998C9E') # 1. This is not valid key from my bot. So don't try to decrypt someone's ids with it. 2. If you want generate new one, just: import os; os.urandom(32).hex().upper()
ADMINS_IDS = [694201337]
BEARER = "YOUR_BEARER"
GALLERY_CHAT_ID = None
QUERY_URL = "https://api.openai.com/v1/images/generations"
proxies = {'http': '"103.239.52.191:33427","103.207.8.130:23804","103.75.184.179:51465","103.120.135.229:33427","111.1.91.177:7302","117.86.111.68:1080","123.31.12.184:28417","122.252.230.117:7497","119.91.78.149:17070","119.123.243.193:1080","111.199.70.169:1080","147.139.133.15:61524","136.243.148.97:25928","132.148.155.12:33647","142.93.162.127:28860","159.65.116.119:30199","149.202.164.5:51023","137.184.100.192:37444","144.217.7.124:39260","174.75.211.222:4145","174.77.111.198:49547","174.64.199.79:4145","174.138.52.209:40694","174.77.111.197:4145","176.99.2.43:1080","174.64.199.82:4145","192.111.137.37:18762","184.178.172.18:15280","184.181.217.194:4145","184.178.172.23:4145","184.178.172.14:4145","184.181.217.213:4145","184.178.172.5:15303","184.178.172.11:4145","203.153.36.37:7497","199.241.139.74:51834","198.8.94.174:39078","195.9.21.26:5002","210.211.122.40:43175","195.201.225.104:23224","20.247.104.85:49999","194.163.187.30:26177","37.99.224.225:7497","24.249.199.12:4145","37.18.73.60:5566","38.127.179.107:42908","24.249.199.4:4145","51.68.94.167:47159","46.147.194.197:1080","58.214.88.130:24388","45.55.196.194:44187","51.68.87.157:49320","45.77.39.10:64817","45.77.39.10:52644","72.206.181.105:64935","72.195.34.35:27360","72.206.181.97:64943","66.42.224.229:41679","72.195.114.169:4145","69.61.200.104:36181","72.210.221.197:4145","65.169.38.73:26592","104.251.81.87:14778","103.28.209.211:3820","113.176.118.150:1080","124.161.205.232:24388","125.141.139.198:5566","128.199.125.165:10260","115.239.254.149:1080","149.154.69.203:3080","136.243.148.97:63462","138.197.138.160:19363","143.198.49.49:3240","160.251.44.173:24818","157.245.210.217:37864","138.197.138.160:35055","159.89.190.254:48829","178.62.229.24:49395","174.77.111.196:4145","181.107.210.193:3128","192.252.208.70:1428","184.178.172.28:15294","185.6.10.41:28150","192.111.130.5:17002","184.181.217.201:4145","185.25.119.57:7497","186.126.53.122:1080","184.178.172.13:15311","203.189.142.33:4145","210.211.122.40:49264","200.16.68.111:7497","222.186.52.11:53335","209.141.56.216:10898","206.189.140.176:21657","198.8.94.170:4145","38.127.173.113:46656","43.240.113.88:42643","45.12.115.103:6226","44.195.36.104:443","31.170.56.85:4145","51.75.124.39:11332","47.113.86.227:10705","45.77.194.89:58647","51.79.51.174:10328","109.94.74.29:1080","70.166.167.55:57745","72.217.216.239:4145","104.238.96.101:11257","70.166.167.38:57728","129.154.54.211:40091","72.195.114.184:4145","117.242.225.40:5678","157.245.1.59:57998","138.68.17.164:52399","138.94.92.26:7497","167.172.23.19:13180","166.62.82.118:26811","161.35.229.155:38931","157.245.1.59:51438","162.243.140.82:55145","67.201.33.10:25283","72.210.252.134:46164","72.210.208.101:4145","72.221.196.157:35904","192.111.135.17:18302","184.181.217.206:4145","188.166.99.171:48372","192.111.139.162:4145","184.178.172.25:15291","212.48.152.181:1080","5.161.100.145:1080","202.92.5.126:44879","72.195.34.41:4145","79.137.34.35:28476","104.255.170.69:64501","51.91.21.129:44121","72.195.34.42:4145","46.101.103.161:35623","72.206.181.103:4145","46.32.230.136:7497","121.234.63.215:24388","165.154.227.154:25031","146.19.191.116:1080","142.93.162.127:31230","167.86.99.193:34990","158.69.197.113:7497","165.227.139.174:59519","72.210.221.223:4145","72.221.232.155:4145","54.36.108.221:40305","77.37.215.25:8081","72.49.49.11:31034","37.187.133.177:56954","192.111.135.18:18301","43.252.228.132:49881","192.111.130.2:4145","192.111.138.29:4145","192.111.139.163:19404","222.95.242.184:23456","72.195.34.58:4145","91.121.210.56:22678","58.210.196.42:7302","72.210.252.137:4145","210.211.122.40:42879","72.206.181.123:4145","5.135.191.56:56750","124.163.236.54:7302","167.99.201.165:13020","151.80.119.118:1080","143.244.184.250:37237","159.65.148.165:12383","167.99.201.165:15956","72.221.172.203:4145","81.169.137.121:47374","98.162.25.4:31654","77.220.40.102:1080","39.108.102.73:5100","72.195.34.59:4145","91.135.80.66:33427","192.248.190.249:42115","59.49.33.221:7302","72.221.164.34:60671","192.111.139.165:4145","222.84.249.228:33080","91.121.210.56:35578","51.254.211.171:7497","170.238.79.2:7497","159.69.43.215:22139","159.69.153.169:5566","192.252.215.5:16137","192.111.137.34:18765","160.251.44.173:12522","85.133.229.10:1080","91.121.210.56:38394","192.111.137.35:4145","45.142.182.99:1080","72.221.171.135:4145","98.170.57.249:4145","192.252.209.155:14455","61.154.96.218:57114","72.221.171.130:4145","192.169.197.17:32647","91.121.210.56:60191","51.75.124.39:47819","98.162.25.7:31653","89.223.122.218:7777","98.188.47.132:4145","192.252.220.92:17328","95.104.194.240:1080","192.248.190.249:12916","192.169.197.17:27350","95.217.144.183:44965","98.162.96.53:10663","98.162.25.23:4145","96.45.169.55:8081","192.252.208.67:14287","165.22.209.96:25150","98.162.25.16:4145","192.252.208.70:14282","98.170.57.231:4145","98.188.47.150:4145","98.162.96.52:4145","98.175.31.195:4145","165.227.139.174:53913","98.162.25.29:31679","43.240.113.89:45597","192.252.211.197:14921","192.252.214.20:15864","98.162.96.41:4145","166.62.52.254:11557","98.178.72.21:10919","","158.69.197.113:7497","142.93.113.81:7497","159.89.50.121:7497","45.42.177.50:3128","45.42.177.17:3128","51.222.13.193:10084","35.193.225.103:80","45.42.177.49:3128","44.195.36.104:443","155.138.132.50:80","5.161.100.145:1080","104.45.128.122:80","54.36.26.122:80","45.42.177.34:3128","165.154.235.76:80","165.154.235.188:80","165.154.235.156:80","51.38.191.151:80","88.210.37.28:80","46.101.156.28:80","198.49.68.80:80","34.110.251.255:80","64.225.104.77:80","185.76.10.68:8080","24.109.252.48:80","51.79.51.174:10328","204.10.182.34:39593","200.16.68.111:7497","134.209.143.56:7497","64.235.204.107:3128","","95.216.215.69:3128","20.54.56.26:8080","134.209.9.131:7497","138.68.45.72:7497","161.35.233.210:7497","82.223.102.92:9443","139.59.186.196:7497","51.38.191.30:7497","184.178.172.28:15294","184.178.172.26:4145","174.138.6.8:7497","157.230.8.196:7497","72.210.221.197:4145","184.178.172.3:4145","184.181.217.201:4145","184.181.217.194:4145","184.178.172.5:15303","184.178.172.17:4145","72.210.252.137:4145","72.206.181.97:64943","98.162.25.4:31654","98.162.25.23:4145","98.162.25.7:31653","184.181.217.206:4145","72.210.221.223:4145","172.81.60.160:2019","72.206.181.123:4145","70.166.167.55:57745","184.178.172.11:4145","184.178.172.25:15291","167.172.148.49:3128", "50.174.7.162:80", "50.174.7.152:80", "50.174.7.158:80", "50.174.7.156:80", "50.174.7.157:80", "50.174.7.155:80", "50.219.67.224:80", "50.219.67.231:80", "64.201.163.133:80", "167.172.133.89:31280", "50.218.57.74:80", "50.218.57.66:80", "50.218.57.64:80", "50.218.57.65:80", "50.218.57.71:80", "50.218.57.68:80", "50.218.57.67:80", "50.221.166.2:80", "50.217.22.105:80", "50.217.22.107:80", "50.219.85.106:80", "50.217.22.110:80", "50.217.22.111:80", "50.217.22.108:80", "107.1.93.222:80", "107.1.93.211:80", "107.1.93.216:80", "107.1.93.217:80", "104.129.194.104:10336", "107.1.93.210:80", "50.217.22.114:80", "50.217.22.106:80", "107.1.93.220:80", "50.174.7.153:80", "50.217.22.104:80", "50.217.22.109:80", "50.219.85.114:80", "50.219.85.117:80", "163.116.158.213:8081", "50.218.57.70:80", "107.1.93.212:80", "50.228.141.103:80", "50.170.0.182:80", "50.228.141.98:80", "50.228.141.97:80", "50.170.0.179:80", "50.228.141.102:80", "50.228.141.100:80", "50.228.141.96:80", "50.228.141.99:80", "50.169.44.44:80", "50.228.83.226:80", "50.217.226.43:80", "50.217.226.40:80", "50.217.226.41:80", "50.202.75.26:80", "50.217.226.47:80", "50.217.153.73:80", "50.217.226.44:80", "50.220.21.202:80", "50.217.153.76:80", "50.217.153.74:80", "50.217.153.75:80", "50.217.153.72:80", "50.217.153.78:80", "50.217.153.77:80", "50.217.226.42:80", "193.122.197.154:80", "50.217.153.79:80", "50.221.230.186:80", "50.206.111.89:80", "50.206.111.88:80", "50.206.111.90:80", "50.235.240.86:80", "163.116.158.28:8081", "163.116.158.143:8081", "50.206.111.91:80", "129.153.163.10:80", "50.228.141.101:80", "51.81.32.81:8888", "50.219.71.165:80", "50.206.25.107:80", "50.206.25.108:80", "50.219.71.162:80", "50.206.25.109:80", "50.206.25.105:80", "50.206.25.111:80", "50.219.71.161:80", "50.219.71.166:80", "50.206.25.104:80", "50.206.25.106:80", "50.219.71.167:80", "50.204.233.30:80", "50.206.25.110:80", "163.116.158.23:8081", "50.220.189.30:80", "50.223.38.6:80", "50.237.89.170:80", "50.237.89.164:80", "50.237.89.165:80", "50.237.89.166:80", "50.237.89.167:80", "50.237.89.160:80", "50.237.89.161:80", "50.237.89.162:80", "50.237.89.163:80", "68.188.59.198:80", "50.223.129.110:80", "50.223.129.105:80", "50.223.129.104:80", "50.171.2.13:80", "50.223.129.111:80", "50.171.2.8:80", "50.171.2.9:80", "163.116.158.118:8081", "50.220.168.134:80", "163.116.158.117:8081", "50.122.86.118:80", "163.116.158.142:8081", "50.219.71.164:80", "24.129.240.222:80", "20.110.99.169:80", "96.113.159.162:80", "50.173.157.75:80", "50.173.157.70:80", "50.173.157.79:80", "96.113.158.126:80", "50.173.204.197:80", "50.173.204.199:80", "50.173.204.194:80", "50.173.204.195:80", "50.173.204.202:80", "50.173.204.198:80", "3.129.17.133:80", "3.137.223.188:3128", "24.158.29.166:80", "50.173.200.97:80", "50.173.200.99:80", "54.209.104.192:3128", "104.129.194.38:8800", "71.255.153.117:80", "50.172.156.144:80", "50.172.156.148:80", "50.172.156.151:80", "154.38.161.241:80", "50.172.156.145:80", "165.225.38.32:10605", "192.151.146.242:3128", "163.116.158.116:8081", "165.225.208.101:10605", "163.116.158.115:8081", "50.233.115.151:80", "50.217.44.178:80", "50.217.44.153:80", "172.177.221.87:80", "45.250.163.171:8081", "50.217.44.154:80", "50.217.44.152:80", "165.225.56.118:10605", "50.218.57.69:80", "82.117.252.100:80", "50.169.135.10:80", "66.220.129.39:3128", "159.203.61.169:8080", "24.95.253.39:80", "45.250.163.170:8081", "50.207.253.118:80", "50.204.219.231:80", "50.204.219.230:80", "50.204.219.227:80", "50.204.219.226:80", "50.204.190.234:80", "50.204.219.229:80", "50.227.121.35:80"'}

async def generate_images(req):
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {BEARER}"
    }
    data ={

        "prompt": str(req),
        "num_images":1,
        "size":"512x512",
        "response_format":"url"
    }

    
    resp = requests.post(QUERY_URL, headers=headers, data=json.dumps(data, ensure_ascii=False), proxies=proxies)

    if resp.status_code != 200:
        if resp.json()["error"]["message"] == "Your request was rejected as a result of our safety system. Your prompt may contain text that is not allowed by our safety system.":
            raise AttributeError("Ваш запрос был отклонен нашей системой безопасности. Ваш запрос может содержать текст, не разрешенный нашей системой безопасности.")
        else:
            raise ValueError("Failed to generate image "+resp.text)

    response_text = json.loads(resp.text)
    return response_text['data'][0]['url']


def getStartArgs(text):
    return text.split()[1] if len(text.split()) > 1 else None


from Cryptodome.Cipher import AES
import os

def encrypt_telegram_id(telegram_id: int, secret_key: str) -> bytes:
    """
    encrypts a tg user ID using AES-256 encryption
    """
    # convert the Telegram ID to bytes
    telegram_id_bytes = str(telegram_id).encode()

    # generate a random initialization vector
    iv = os.urandom(16)

    # create an AES cipher
    cipher = AES.new(secret_key, AES.MODE_CBC, iv)

    # pad the Telegram ID bytes to a multiple of 16
    telegram_id_bytes = _pad_bytes(telegram_id_bytes)

    # encrypt the Telegram ID
    ciphertext = cipher.encrypt(telegram_id_bytes)

    # concatenate the initialization vector and ciphertext
    encoded_ciphertext = iv + ciphertext

    return encoded_ciphertext

def decrypt_telegram_id(encoded_ciphertext: bytes, secret_key: str) -> int:
    """
    decrypts a tg user ID that was encrypted using AES-256 encryption
    """
    # split the encoded ciphertext into the initialization vector and ciphertext
    iv = encoded_ciphertext[:16]
    ciphertext = encoded_ciphertext[16:]

    # create an AES cipher
    cipher = AES.new(secret_key, AES.MODE_CBC, iv)

    # decrypt the Telegram ID
    telegram_id_bytes = cipher.decrypt(ciphertext)

    # remove the padding from the Telegram ID bytes
    telegram_id_bytes = _unpad_bytes(telegram_id_bytes)

    # convert the Telegram ID bytes to an integer
    telegram_id = int(telegram_id_bytes.decode())

    return telegram_id

def _pad_bytes(data: bytes) -> bytes:
    """
    ;ads the given bytes to a multiple of 16 using PKCS7 padding
    """
    padding_length = 16 - (len(data) % 16)
    padding = bytes([padding_length]) * padding_length
    return data + padding

def _unpad_bytes(data: bytes) -> bytes:
    """
    removes the PKCS7 padding from the given bytes
    """
    padding_length = data[-1]
    return data[:-padding_length]


@dp.message_handler(commands='start')
async def msg(m):
    cdb = CDB()
    if cdb.load(m["chat"]["id"]):
        pass
    else:
        cdata = {
            "ID": m["chat"]["id"],
            "name": m["chat"]["title"]
            }
        cdb.new(cdata)
        print("New channel was registred. ({})".format(m["chat"]["id"]))
    user = DB().load(m.from_user.id)
    if not user:
        DB().new(m.from_user.id, {"ai_coins": 25, "reffed": []})
    user = DB().load(m.from_user.id)[0]
    data = json.loads(user[1])
    await m.reply(f"<b>❄️ Добро пожаловать в DALLE-2 AI!</b>\n\n• <b>DALLE-2</b> — это новая система искусственного интеллекта, которая может создавать реалистичные изображения и рисунки из описания на естественном языке. 🤖\n\n• Чтобы сделать запрос, просто напиши его в этот чат, каждый запрос стоит <b><i>1 AI коин</i></b>, сейчас у тебя на балансе <b><i>{data['ai_coins']} AI коинов</i></b>.\n<i>Чтобы получить больше AI коинов, напиши /coins</i>")
    unique_code = getStartArgs(m.text)
    if unique_code:
        id_key_bytes = bytes.fromhex(unique_code)

        decrypted_telegram_id = decrypt_telegram_id(id_key_bytes, secret_key)
        user = DB().load(decrypted_telegram_id)[0]
        data = json.loads(user[1])
        by_who = base64.b64encode(str.encode(encrypt_telegram_id(m.from_user.id, secret_key).hex())).decode().replace("=", "")
        if m.from_user.id == decrypted_telegram_id:
            await m.reply('умный самый или че бля.')
            return
        elif m.from_user.id in data['reffed']:
            return

        else:
            data['ai_coins'] += 10
            data['reffed'].append(m.from_user.id)
            DB().update(decrypted_telegram_id, 'data', json.dumps(data))
            await bot.send_message(decrypted_telegram_id, f'💳 <b>{by_who}</b> перешел по твоей реферальной ссылке, тебе выдано <b>10 AI коинов</b>. Теперь твой баланс составляет <b>{data["ai_coins"]} AI коинов</b>')
    else:
        pass
        #если в ссылке нет id рефера

@dp.message_handler(commands='give')
async def give(m):
    if m.from_user.id == 5450202024:
        to = m.text.split()[1]
        val = m.text.split()[2]
        try:
            user = DB().load(int(to))[0]
            data = json.loads(user[1])
            data["ai_coins"] += int(val)
            DB().update(int(to), "data", json.dumps(data, ensure_ascii=False))
            to_who = base64.b64encode(str.encode(encrypt_telegram_id(int(to), secret_key).hex())).decode().replace("=", "")
            await m.reply(f'💳 Пользователю <b>{to_who}</b> успешно выдано {val} AI коинов!')

        except:
            await m.reply(traceback.format_exc())


@dp.message_handler(commands='coins')
async def msg(m):
    encrypted_telegram_id = encrypt_telegram_id(m.from_user.id, secret_key)
    await m.reply(f'💳 Ты можешь заработать дополнительные <b>AI коины</b> благодаря реферальным ссылкам!\n\n- Отличие наших реферальных ссылок от других: в рефералке не хранится открыто ваш ID, а зашифрованный с помощью уникального ключа код. Код меняется после каждой команды, но все предыдущие остаются действительными.\n\nТвоя реф ссылка: <b>https://t.me/dalle2_bot?start={encrypted_telegram_id.hex()}</b>\n\n(а если тебе некому отправить ссылку, жди возможность пополнить за реальные деньги)')
@dp.message_handler(commands='stats')
async def stats(m):
    users = len(DB().loadall())
    users_annc = len(CDB().loadall())
    proxies_count = len(proxies['http'])
    await m.reply(f'❄️ Статистика бота:\n- <b>{users}</b> пользователей\n- <b>{users_annc}</b> пользователей для рассылки\n- <b>{proxies_count}</b> прокси.')
"""
annc - old shity code that i use in all my bots, cus i lazy to remake it. lmao

"""
@dp.message_handler(commands='annc')
async def s(ctx):
	if ctx["from"]["id"] in ADMINS_IDS:
		users = CDB().loadall()
		trac = 0
		for i in users:
			try:
				await bot.send_message(i[0], ctx.text[6:], parse_mode="HTML")
				trac += 1
			except:
				CDB().delete(i[0])
		await ctx.reply(f'Сообщение разослано {trac} каналам.')


@dp.message_handler()
async def msg(m):
    user = DB().load(m.from_user.id)[0]
    data = json.loads(user[1])
    if int(data['ai_coins']) < 1:
        await m.reply('❌ <b>Недостаточно AI коинов! Чтобы узнать, как получить больше коинов, напиши /coins</b>')
        return
    try:
        m.text.replace("\n", " ")
        await m.reply('Ожидайте...')
        await bot.send_sticker(m.chat.id, "CAACAgIAAxkBAAEHPJxjwV-dhhQDrC1mQFjjKzZtjqkxpgACiCQAApKnKEotb-OqIwi7yi0E")
        text = translator.translate(m.text, dest='en').text
        img = await generate_images(str(text.encode("utf-8")))
        await bot.send_photo(m.chat.id, img, m.text + "\n<a href='https://t.me/dalle2gallery'>галерея бота лол</a>")
        a = m.text.split()
        stringi = ""
        for i in a:
            if "http" in i or "@" in i:
                pass
            else:
                stringi += i + " "
        b = text.split()
        stringy = ""
        for y in b:
            if "http" in y or "@" in y:
                pass
            else:
                stringy += y + " "
        if GALLERY_CHAT_ID:
            await bot.send_photo(GALLERY_CHAT_ID, img, stringi + "\n\n" + stringy)
        data['ai_coins'] -= 1
        DB().update(m.from_user.id, 'data', json.dumps(data, ensure_ascii=False))
    except AttributeError:
        await m.reply("Ваш запрос был отклонен нашей системой безопасности. Ваш запрос может содержать текст, не разрешенный нашей системой безопасности. AI коины не списаны.")
        await bot.send_sticker(m.chat.id, "CAACAgIAAxkBAAEHPJ5jwWAF2Luzpno5U3qNO_95JMjaNwAC1SMAAiorKUrS02hTXq22ly0E")
    except ValueError:
        await m.reply("Произошла ошибка! Администратору бота отправлен отчёт об ошибке. AI коины не списаны.")
        await bot.send_sticker(m.chat.id, "CAACAgIAAxkBAAEHPJ5jwWAF2Luzpno5U3qNO_95JMjaNwAC1SMAAiorKUrS02hTXq22ly0E")
        for i in ADMINS_IDS:
            await bot.send_message(i, traceback.format_exc())


"""
THIS ALSO OLD ONE LOOOL
"""
@dp.message_handler(content_types="any")
async def a(ctx):
	cdb = CDB()
	if cdb.load(ctx["chat"]["id"]):
		pass
	else:
		cdata = {
			"ID": ctx["chat"]["id"],
			"name": ctx["chat"]["title"]
		}
		cdb.new(cdata)
		print("New channel was registred. ({})".format(ctx["chat"]["id"]))

executor.start_polling(dp, skip_updates=True)


